{"version":3,"file":"relinx.cjs.production.min.js","sources":["../src/context.ts","../src/PathNode.ts","../src/utils/infoLog.ts","../src/utils/toString.ts","../src/utils/shallowEqual.ts","../src/Application.ts","../src/utils/ifType.ts","../src/utils/key.ts","../src/AutoRunner.ts","../src/autoRun.ts","../src/Store.ts","../src/globalHelper.ts","../src/hooks/useGlobal.ts","../src/middleware/logger/utils.ts","../src/middleware/logger/print.ts","../src/Patcher.ts","../src/observe.tsx","../src/Provider.tsx","../src/applyMiddleware.ts","../src/utils/compose.ts","../src/createStore.ts","../src/middleware/logger/index.ts","../src/middleware/thunk.ts","../src/hooks/useDispatch.ts","../src/hooks/useNamespace.ts","../src/hooks/useRelinx.ts"],"sourcesContent":["import { createContext } from 'react';\nimport { ContextDefaultValue } from './types';\n\nconst calculateChangeBits = () => 0b00;\nconst noop = () => {};\n\nexport const defaultValue = {\n  computation: null,\n  dispatch: noop,\n  attachStoreName: noop,\n  useProxy: true,\n  namespace: null,\n  patcher: null,\n  trackerNode: null,\n  useRelinkMode: true,\n  application: null,\n};\n\n// @ts-ignore\nexport default createContext<ContextDefaultValue<T, M>>(\n  defaultValue,\n  // @ts-ignore\n  calculateChangeBits\n);\n","import infoLog from './utils/infoLog';\nimport Patcher from './Patcher';\nimport AutoRunner from './AutoRunner';\n\nconst DEBUG = false;\n\ntype Children = {\n  [key: string]: PathNode;\n};\n\ntype ToHandlerMap<T> = T extends Field.Patchers ? Patcher : AutoRunner;\n\nenum Field {\n  Patchers = 'patchers',\n  AutoRunners = 'autoRunners',\n}\n\nclass PathNode {\n  private parent: PathNode | undefined;\n  public patchers: Array<Patcher>;\n  public autoRunners: Array<AutoRunner>;\n  public children: Children;\n  private prop: string;\n\n  constructor(prop?: string, parent?: PathNode) {\n    this.prop = prop || 'root';\n\n    this.parent = parent;\n    this.children = {};\n    this.patchers = [];\n    this.autoRunners = [];\n  }\n\n  addPatcher(path: Array<string>, patcher: Patcher) {\n    this.addPathNode(path, patcher, Field.Patchers);\n  }\n\n  destroyPatcher() {}\n\n  addAutoRunner(path: Array<string>, autoRunner: AutoRunner) {\n    this.addPathNode(path, autoRunner, Field.AutoRunners);\n  }\n\n  destroyAutoRunner() {}\n\n  getCollection<T extends Field>(field: T): Array<Patcher> | Array<AutoRunner> {\n    if (field === Field.Patchers) {\n      return this.patchers;\n    }\n    return this.autoRunners;\n  }\n\n  addPathNode<T extends Field>(\n    path: Array<string>,\n    handler: ToHandlerMap<T>,\n    field: T\n  ) {\n    try {\n      const len = path.length;\n      path.reduce<PathNode>((node: PathNode, cur: string, index: number) => {\n        // path中前面的值都是为了让我们定位到最后的需要关心的位置\n        if (!node.children[cur]) node.children[cur] = new PathNode(cur, node);\n        // 只有到达`path`的最后一个`prop`时，才会进行patcher的添加\n        if (index === len - 1) {\n          const childNode = node.children[cur];\n          if (DEBUG) {\n            infoLog('[PathNode add handler]', childNode, handler);\n          }\n          const collection = childNode.getCollection(field) as Array<\n            ToHandlerMap<T>\n          >;\n\n          if (collection) {\n            collection.push(handler);\n            handler.addRemover(() => {\n              const index = collection.indexOf(handler);\n\n              if (DEBUG) {\n                infoLog('[PathNode remove handler]', handler.id, childNode);\n              }\n              if (index !== -1) {\n                collection.splice(index, 1);\n              }\n            });\n          }\n        }\n        return node.children[cur];\n      }, this);\n    } catch (err) {\n      // console.log('err ', err)\n    }\n  }\n\n  destroyPathNode() {\n    try {\n      this.patchers.forEach(patcher => patcher.destroyPatcher());\n\n      if (this.children) {\n        const childKeys = Object.keys(this.children);\n        childKeys.forEach(key => {\n          const pathNode = this.children[key];\n          pathNode.destroyPathNode();\n        });\n      }\n\n      if (this.parent) {\n        delete this.parent.children[this.prop];\n      }\n    } catch (err) {\n      infoLog('[PathNode destroy issue]', err);\n    }\n  }\n}\n\nexport default PathNode;\n","/**\n * Intentional info-level logging for clear separation from ad-hoc console debug logging.\n */\nfunction infoLog(...args: Array<any>) {\n  console.log('**DEBUG**', ...args); // eslint-disable-line\n}\n\nexport default infoLog;\n","const toString = Function.call.bind(Object.prototype.toString);\n\nexport default toString;\n","// https://github.com/facebook/react/blob/144328fe81719e916b946e22660479e31561bb0b/packages/shared/shallowEqual.js#L36-L68\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/* eslint-disable no-self-compare */\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x: any, y: any) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  }\n  // Step 6.a: NaN == NaN\n  return x !== x && y !== y;\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA: any, objB: any) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !hasOwnProperty.call(objB, keysA[i]) ||\n      !is(objA[keysA[i]], objB[keysA[i]])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport default shallowEqual;\n","import PathNode from './PathNode';\nimport infoLog from './utils/infoLog';\nimport { isTypeEqual, isPrimitive, isMutable } from './utils/ifType';\nimport shallowEqual from './utils/shallowEqual';\nimport {\n  Action,\n  IApplication,\n  GenericState,\n  PendingPatcher,\n  PendingAutoRunner,\n  ChangedValueGroup,\n} from './types';\nimport Patcher from './Patcher';\nimport produce, { ProxyState } from 'state-tracker';\nimport AutoRunner from './AutoRunner';\n\nclass Application<T, K extends keyof T> implements IApplication<T, K> {\n  public base: GenericState<T, K>;\n  public node: PathNode;\n  public autoRunnerNode: PathNode;\n  public pendingPatchers: Array<PendingPatcher>;\n  public pendingAutoRunners: Array<PendingAutoRunner>;\n  public pendingCleaner: Array<Function>;\n  public namespace: string;\n  public strictMode: boolean;\n  public proxyState: ProxyState;\n\n  constructor({\n    base,\n    namespace,\n    strictMode,\n  }: {\n    base: GenericState<T, K>;\n    namespace: string;\n    strictMode: boolean;\n  }) {\n    this.base = base;\n    this.node = new PathNode();\n    this.autoRunnerNode = new PathNode();\n    this.pendingPatchers = [];\n    this.pendingAutoRunners = [];\n    this.pendingCleaner = [];\n    this.namespace = namespace;\n    this.strictMode = strictMode;\n    this.proxyState = produce(this.base);\n  }\n\n  processAutoRunner(values: Array<ChangedValueGroup<K>>) {\n    this.pendingAutoRunners = [];\n\n    try {\n      values.forEach(value => this.treeShakeAutoRunner(value));\n    } catch (err) {\n      infoLog('[Application] processAutoRunner issue ', err);\n    }\n  }\n\n  update(values: Array<ChangedValueGroup<K>>) {\n    try {\n      values.forEach(value => this.treeShake(value));\n      values.forEach(value => this.updateBase(value));\n    } catch (err) {\n      infoLog('[Application] update issue ', err);\n    }\n\n    this.pendingPatchers.forEach(({ patcher }) => {\n      patcher.triggerAutoRun();\n    });\n    this.pendingPatchers = [];\n\n    this.pendingAutoRunners = [];\n\n    this.pendingCleaner.forEach(clean => clean());\n    this.pendingCleaner = [];\n  }\n\n  updateDryRun(values: Array<ChangedValueGroup<K>>): Array<Action> {\n    let actions = [] as Array<Action>;\n\n    try {\n      values.forEach(value => this.treeShake(value));\n      this.processAutoRunner(values);\n      values.forEach(value => this.updateBase(value));\n      this.pendingAutoRunners.forEach(({ autoRunner }) => {\n        actions = actions.concat(autoRunner.triggerAutoRun());\n      });\n    } catch (err) {\n      infoLog('[Application] update issue ', err);\n    }\n\n    return actions;\n  }\n\n  updateBase({\n    storeKey,\n    changedValue,\n  }: {\n    storeKey: K;\n    changedValue: object;\n  }) {\n    const origin = this.base[storeKey] || ({} as any);\n    this.proxyState.relink([storeKey as string], {\n      ...origin,\n      ...changedValue,\n    });\n  }\n\n  addPatchers(patchers: Array<Patcher>) {\n    if (patchers.length) {\n      patchers.forEach(patcher => {\n        this.pendingPatchers.push({ patcher });\n      });\n      patchers.forEach(patcher => {\n        patcher.markDirty();\n      });\n    }\n  }\n\n  addAutoRunners(autoRunners: Array<AutoRunner>) {\n    if (autoRunners.length) {\n      autoRunners.forEach(autoRunner => {\n        if (!autoRunner.isDirty()) {\n          this.pendingAutoRunners.push({ autoRunner });\n          this.pendingCleaner.push(autoRunner.markClean.bind(autoRunner));\n        }\n      });\n      autoRunners.forEach(autoRunner => {\n        autoRunner.markDirty();\n      });\n    }\n  }\n\n  compare(\n    branch: PathNode,\n    baseValue: {\n      [key: string]: any;\n    },\n    nextValue: {\n      [key: string]: any;\n    },\n    cb: {\n      (pathNode: PathNode): void;\n    }\n  ) {\n    const keysToCompare = Object.keys(branch.children);\n\n    keysToCompare.forEach(key => {\n      const oldValue = baseValue[key];\n      const newValue = nextValue[key];\n\n      if (shallowEqual(oldValue, newValue)) return;\n\n      if (isTypeEqual(oldValue, newValue)) {\n        if (isPrimitive(newValue)) {\n          if (oldValue !== newValue) {\n            cb(branch.children[key]);\n            // this.addPatchers(branch.children[key].patchers);\n          }\n        }\n\n        if (isMutable(newValue)) {\n          const childBranch = branch.children[key];\n          this.compare(childBranch, oldValue, newValue, cb);\n          return;\n        }\n\n        return;\n      }\n      cb(branch.children[key]);\n      // this.addPatchers(branch.children[key].patchers);\n    });\n  }\n\n  treeShakeAutoRunner({\n    storeKey,\n    changedValue,\n  }: {\n    storeKey: K;\n    changedValue: object;\n  }) {\n    const branch = this.autoRunnerNode.children[storeKey as any];\n    const baseValue = this.base[storeKey];\n    const nextValue = { ...baseValue, ...changedValue };\n\n    // why it could be undefined. please refer to https://github.com/ryuever/relinx/issues/4\n    if (!branch) return;\n    this.compare(branch, baseValue, nextValue, (pathNode: PathNode) => {\n      this.addAutoRunners(pathNode.autoRunners);\n    });\n  }\n\n  /**\n   *\n   * Recently it only support `Array`, `Object`, `Number`, `String` and `Boolean` five\n   * types..\n   */\n  treeShake({ storeKey, changedValue }: { storeKey: K; changedValue: object }) {\n    const branch = this.node.children[storeKey as any];\n    const baseValue = this.base[storeKey];\n    const nextValue = { ...baseValue, ...changedValue };\n\n    // why it could be undefined. please refer to https://github.com/ryuever/relinx/issues/4\n    if (!branch) return;\n    this.compare(branch, baseValue, nextValue, (pathNode: PathNode) => {\n      this.addPatchers(pathNode.patchers);\n    });\n  }\n\n  addPatcher(patcher: Patcher) {\n    const paths = patcher.paths;\n\n    paths.forEach(fullPath => {\n      this.node.addPatcher(fullPath, patcher);\n    });\n  }\n\n  addAutoRunner(autoRunner: AutoRunner) {\n    const paths = autoRunner.paths;\n    paths.forEach(fullPath => {\n      this.autoRunnerNode.addAutoRunner(fullPath, autoRunner);\n    });\n  }\n\n  getStoreData(storeName: K): T[K] {\n    const storeValue = this.base[storeName];\n    return storeValue;\n  }\n}\n\nexport default Application;\n","import toString from './toString';\n\nexport const isPresent = (o: any) => typeof o !== 'undefined';\nexport const isObject = (obj: any) => toString(obj) === '[object Object]';\nexport const isArray = (obj: any) => toString(obj) === '[object Array]';\nexport const isNumber = (obj: any) => toString(obj) === '[object Number]';\nexport const isString = (obj: any) => toString(obj) === '[object String]';\nexport const isBoolean = (obj: any) => toString(obj) === '[object Boolean]';\n\nexport const isMutable = (obj: any) => isObject(obj) || isArray(obj);\nexport const isPrimitive = (obj: any) =>\n  isNumber(obj) || isString(obj) || isBoolean(obj);\nexport const isTypeEqual = (o1: any, o2: any) => toString(o1) === toString(o2);\n\nexport const isStrictEmptyObject = (obj: any) => {\n  if (!isObject(obj)) return false;\n\n  for (const prop in obj) { // eslint-disable-line\n    if (obj.hasOwnProperty(prop)) return false // eslint-disable-line\n  }\n  return true;\n};\n\nexport const isStrictEmptyArray = (arr: any) => isArray(arr) && !arr.length;\n\nexport const hasEmptyItem = (...args: Array<any>) =>\n  args.some(arg => isStrictEmptyArray(arg) || isStrictEmptyObject(arg));\n","// https://github.com/facebook/draft-js/blob/master/src/model/keys/generateRandomKey.js\n\ninterface SeenKeys {\n  [key: string]: boolean;\n}\n\ninterface PatcherIds {\n  [key: string]: number;\n}\n\ninterface PatcherSeenKeys {\n  [key: string]: {\n    [key: string]: number;\n  };\n}\n\nconst seenKeys: SeenKeys = {};\nconst MULTIPLIER = Math.pow(2, 24) // eslint-disable-line\n\nexport const generateNamespaceKey = () => {\n  let key;\n\n  while (key === undefined || seenKeys.hasOwnProperty(key) || !isNaN(+key)) { // eslint-disable-line\n    key = Math.floor(Math.random() * MULTIPLIER).toString(32);\n  }\n\n  seenKeys[key] = true;\n  return key;\n};\n\nconst patcherIds: PatcherIds = {};\nexport const generatePatcherId = ({\n  namespace,\n}: {\n  namespace: string;\n}): string => {\n  const count = patcherIds[namespace] || 0;\n  const next = count + 1;\n  patcherIds[namespace] = next;\n  return `${namespace}_patcherId_${count}`;\n};\n\nconst patcherSeenKeys: PatcherSeenKeys = {};\nexport const generatePatcherKey = ({\n  namespace,\n  componentName,\n}: {\n  namespace: string;\n  componentName: string;\n}) => {\n  if (!patcherSeenKeys[namespace]) patcherSeenKeys[namespace] = {};\n  const count = patcherSeenKeys[namespace][componentName] || 0;\n  const next = count + 1;\n  patcherSeenKeys[namespace][componentName] = next;\n  return `${namespace}_${componentName}_patcher_${count}`;\n};\n\nexport const generateRandomGlobalActionKey = () => Math.floor(Math.random() * MULTIPLIER).toString(32) // eslint-disable-line\n","import { AutoRunnerProps } from './types';\n\nlet count = 1;\nclass AutoRunner {\n  private _isDirty: boolean;\n  public paths: Array<Array<string>>;\n  public autoRunFn: Function;\n  public id: string;\n  public removers: Array<Function>;\n\n  constructor({ paths, autoRunFn }: AutoRunnerProps) {\n    this.id = `autoRunner_${count++}`;\n    this.paths = paths;\n    this.autoRunFn = autoRunFn;\n    this._isDirty = false;\n    this.removers = [];\n  }\n\n  addRemover(remover: Function) {\n    this.removers.push(remover);\n  }\n\n  teardown() {\n    this.removers.forEach(remover => remover());\n    this.removers = [];\n  }\n\n  markDirty() {\n    this._isDirty = true;\n  }\n\n  markClean() {\n    this._isDirty = false;\n  }\n\n  isDirty(): boolean {\n    return this._isDirty;\n  }\n\n  triggerAutoRun() {\n    return this.autoRunFn() || [];\n  }\n}\n\nexport default AutoRunner;\n","import invariant from 'invariant';\nimport Application from './Application';\nimport AutoRunner from './AutoRunner';\n\nconst autoRun = <T, K extends keyof T>(\n  fn: Function,\n  application: Application<T, K>\n) => {\n  invariant(application, 'application is required to be initialized already !');\n\n  const state = application.proxyState;\n\n  state.enter();\n  fn({ state });\n  const tracker = state.getContext().getCurrent();\n  const paths = tracker.getRemarkable();\n\n  const autoRunner = new AutoRunner({\n    paths,\n    autoRunFn: () => {\n      return fn({ state });\n    },\n  });\n\n  application.addAutoRunner(autoRunner);\n\n  state.leave();\n};\n\nexport default autoRun;\n","import Application from './Application';\nimport {\n  Action,\n  InternalDispatch,\n  Subscription,\n  BasicModelType,\n  AutoRunSubscriptions,\n  ChangedValueGroup,\n  CreateStoreOnlyModels,\n  ExtractStateTypeOnlyModels,\n  ExtractEffectsTypeOnlyModels,\n  ExtractReducersTypeOnlyModels,\n  PendingAutoRunInitialization,\n} from './types';\nimport autoRun from './autoRun';\n\nclass Store<T extends BasicModelType<T>, MODEL_KEY extends keyof T = keyof T> {\n  private _application: Application<T, MODEL_KEY> | null;\n  private _count: number;\n  public dispatch: InternalDispatch;\n  private _state: ExtractStateTypeOnlyModels<T>;\n  private _reducers: ExtractReducersTypeOnlyModels<T>;\n  private _effects: ExtractEffectsTypeOnlyModels<T>;\n  private _pendingAutoRunInitializations: Array<PendingAutoRunInitialization>;\n  private _pendingActions: Array<Action>;\n  public initialState: any;\n  public subscriptions: {\n    [key: string]: Subscription<ExtractStateTypeOnlyModels<T>>;\n  };\n\n  constructor(configs: {\n    models: CreateStoreOnlyModels<T>;\n    initialValue?: {\n      [key in MODEL_KEY]?: any;\n    };\n  }) {\n    const models = configs.models;\n    const initialValue = configs.initialValue || ({} as any);\n\n    this._state = {} as ExtractStateTypeOnlyModels<T>;\n    this._reducers = {} as ExtractReducersTypeOnlyModels<T>;\n    this._effects = {} as ExtractEffectsTypeOnlyModels<T>;\n    this._pendingActions = [];\n    this._pendingAutoRunInitializations = [];\n\n    const keys = Object.keys(models) as Array<MODEL_KEY>;\n\n    keys.forEach(key => {\n      this.injectModel(key, models[key], initialValue[key]);\n    });\n\n    this.dispatch = () => {};\n    this._application = null;\n    this.subscriptions = {};\n    this._count = 0;\n  }\n\n  getState(): ExtractStateTypeOnlyModels<T> {\n    return this._state;\n  }\n\n  getReducers(): ExtractReducersTypeOnlyModels<T> {\n    return this._reducers;\n  }\n\n  getEffects(): ExtractEffectsTypeOnlyModels<T> {\n    return this._effects;\n  }\n\n  resolveActions(actions: Array<Action>) {\n    return actions.reduce<Array<ChangedValueGroup<MODEL_KEY>>>(\n      (changedValueGroup, action) => {\n        if (!this._application) return [];\n        const { type, payload } = action;\n        const [storeKey, actionType] = type.split('/') as [\n          MODEL_KEY,\n          keyof ExtractReducersTypeOnlyModels<T>\n        ];\n        const usedReducer = this._reducers[storeKey];\n\n        // If usedReducer is null, Maybe you have dispatched an unregistered action.\n        // On this condition, put these actions to `this._pendingActions`\n        if (!usedReducer) {\n          this._pendingActions.push(action);\n        } else if (usedReducer[actionType]) {\n          const currentState = this._application.base[storeKey];\n          const changedValue = usedReducer[actionType](currentState, payload);\n          changedValueGroup.push({\n            storeKey,\n            changedValue,\n          });\n        } else {\n          console.warn(`Do not have action '${actionType}'`);\n        }\n\n        return changedValueGroup;\n      },\n      []\n    );\n  }\n\n  setValue(actions: Array<Action>) {\n    const nextActions = ([] as Array<Action>).concat(actions);\n    const changedValues = this.resolveActions(nextActions);\n\n    if (changedValues.length) {\n      // updateDryRun do two things\n      // 1. resolve pendingPatchers\n      // 2. assign application.base with new value.\n      // Note: on this step, pendingPatchers do not execute\n      const derivedActions =\n        this._application?.updateDryRun(changedValues) || [];\n      // model.subscriptions may cause new value update..\n      const derivedChangedValue = this.resolveActions(derivedActions!);\n      this._application?.update(derivedChangedValue);\n\n      const storeSubscriptionsKeys = Object.keys(this.subscriptions);\n      const storeSubscriptionsKeysLength = storeSubscriptionsKeys.length;\n      // Only if there are store subscriptions. it requires to calculate old and new value..\n      if (storeSubscriptionsKeysLength) {\n        const toObject = changedValues.reduce<\n          {\n            [key in MODEL_KEY]: object;\n          }\n        >(\n          (acc, cur) => {\n            const { storeKey, changedValue } = cur;\n            acc[storeKey] = {\n              ...acc[storeKey],\n              ...changedValue,\n            };\n            return acc;\n          },\n          {} as {\n            [key in MODEL_KEY]: object;\n          }\n        );\n        const oldState = {\n          ...this._application?.base,\n        } as ExtractStateTypeOnlyModels<T>;\n        const newState = {\n          ...this._application?.base,\n          ...toObject,\n        } as ExtractStateTypeOnlyModels<T>;\n        for (let i = 0; i < storeSubscriptionsKeysLength; i++) {\n          const key = storeSubscriptionsKeys[i];\n          const subscription = this.subscriptions[key];\n          subscription({\n            oldState,\n            newState,\n            diff: toObject as Partial<ExtractStateTypeOnlyModels<T>>,\n          });\n        }\n      }\n    }\n  }\n\n  bindApplication(application: Application<T, MODEL_KEY>) {\n    this._application = application;\n    this.runPendingAutoRunInitialization();\n  }\n\n  runPendingAutoRunInitialization() {\n    if (this._pendingAutoRunInitializations.length) {\n      this._pendingAutoRunInitializations.forEach(initialization => {\n        const { autoRunFn } = initialization;\n        autoRun(autoRunFn, this._application!);\n      });\n      this._pendingAutoRunInitializations = [];\n    }\n  }\n\n  decorateDispatch(chainedMiddleware: Function) {\n    this.dispatch = chainedMiddleware(this.setValue.bind(this));\n  }\n\n  generateSubscriptionKey(): string {\n    return `store_${this._count++}`;\n  }\n\n  subscribe(\n    subscription: Subscription<ExtractStateTypeOnlyModels<T>>\n  ): Function {\n    const key = this.generateSubscriptionKey();\n    this.subscriptions[key] = subscription;\n    return () => delete this.subscriptions[key];\n  }\n\n  injectModel(key: MODEL_KEY, model: any, initialValue: any = {}) {\n    const { state, reducers = {}, effects = {} } = model;\n    const subscriptions = model.subscriptions || ({} as AutoRunSubscriptions);\n    // consume all the pending actions.\n    let base = this._application?.getStoreData(key) || {\n      ...state,\n      ...initialValue,\n    };\n\n    const nextPendingActions = this._pendingActions.filter(action => {\n      const { type, payload } = action;\n      const [storeKey, actionType] = type.split('/') as [\n        MODEL_KEY,\n        keyof ExtractReducersTypeOnlyModels<T>\n      ];\n\n      // only process action with current injected model's tag\n      if (key === storeKey) {\n        const reducer = reducers[actionType];\n        const effect = effects[actionType];\n\n        let nextState = base;\n\n        if (typeof reducer === 'function') {\n          nextState = reducer(base, payload);\n          base = { ...base, ...nextState };\n          // what if pending action is an effect. call dispatch again to re-run...\n          // But, there is still a condition, effects followed by normal reducer...\n          // The result may override by effect...\n        } else if (typeof effect === 'function') {\n          this.dispatch(action);\n        } else {\n          console.warn(\n            `Maybe you have dispatched an unregistered model's effect action(${action})`\n          );\n        }\n      }\n\n      return storeKey !== key;\n    });\n\n    const subscriptionsKeys = Object.keys(subscriptions);\n    subscriptionsKeys.forEach(autoRunKey => {\n      const autoRunFn = subscriptions[autoRunKey];\n\n      if (!this._application) {\n        this._pendingAutoRunInitializations.push({\n          modelKey: key as string,\n          autoRunKey,\n          autoRunFn,\n        });\n      } else {\n        autoRun<T, MODEL_KEY>(autoRunFn, this._application);\n      }\n    });\n\n    this._state[key] = base;\n    this._pendingActions = nextPendingActions;\n\n    this._application?.updateBase({\n      storeKey: key,\n      changedValue: base,\n    });\n\n    if (reducers) this._reducers[key] = reducers as any;\n    if (effects) this._effects[key] = effects as any;\n  }\n}\n\nexport default Store;\n","import { Collections, Action } from './types';\n\nclass GlobalHelper {\n  public collections: Collections;\n  constructor() {\n    this.collections = [];\n  }\n\n  addAction(actionKey: string, namespace: string, actions: Array<Action>) {\n    this.collections.push({\n      actionKey,\n      namespace,\n      remover: () => {\n        const index = this.collections.findIndex(\n          ({ actionKey: key }) => key === actionKey\n        );\n        if (index !== -1) this.collections.splice(index, 1);\n      },\n      actions,\n    });\n  }\n}\n\nexport default new GlobalHelper();\n","import invariant from 'invariant';\nimport globalHelper from '../globalHelper';\nimport { generateRandomGlobalActionKey } from '../utils/key';\nimport {\n  GlobalActions,\n  GlobalAction,\n  GlobalDispatch,\n  Collections,\n} from '../types';\n\nconst dispatch = (actions: GlobalActions | GlobalAction) => {\n  const next = ([] as GlobalActions).concat(actions);\n\n  next.forEach(action => {\n    const { namespace: targetNamespace, actions } = action;\n    invariant(targetNamespace, '`namespace` is required for global action');\n    invariant(actions, '`actions` is required for global action');\n    const actionKey = generateRandomGlobalActionKey();\n    globalHelper.addAction(actionKey, targetNamespace, actions);\n  });\n};\n\n// It is not a official documentation compatible Hooks API.\n// For global state, data change responsive is not required, which means\n// value's change will not trigger any UI/data update...\nexport default (): [Collections, GlobalDispatch] => [\n  globalHelper.collections,\n  dispatch,\n];\n","const padding = (value: number, paddingCount = 2) =>\n  `00${value}`.slice(-paddingCount);\n\nexport const formatTime = (d: number) => {\n  const date = new Date(d);\n  const hh = date.getHours();\n  const mm = date.getMinutes();\n  const ss = date.getSeconds();\n  const ms = date.getMilliseconds();\n\n  return `${padding(hh)}:${padding(mm)}:${padding(ss)}.${padding(ms, 3)}`;\n};\n","import { Action } from '../../types';\n\nimport { formatTime } from './utils';\n\nconst colorLine = Function.apply.bind(console.log, null) // eslint-disable-line\nconst colorGroupEnd = console.groupEnd // eslint-disable-line\nconst colorGroupCollapsed = Function.apply.bind(console.groupCollapsed, null) // eslint-disable-line\n// const isEmptyObject = obj => !obj || Object.keys(obj).length === 0 && obj.constructor === Object\n\nconst colorLog = (group: Array<Array<string>>) => {\n  const { text: t, styles: s } = group.reduce(\n    (acc, cur) => {\n      const { text, styles } = acc;\n      const [subText, subStyle] = cur;\n\n      return {\n        text: `${text}%c ${subText}`,\n        styles: ([] as Array<string>).concat(styles, subStyle),\n      };\n    },\n    {\n      text: '',\n      styles: [] as Array<string>,\n    }\n  );\n\n  return [t, ...s];\n};\n\nconst renderTitle = (props: {\n  initialActions: Array<Action>;\n  startTime: number;\n  endTime: number;\n}) => {\n  const { initialActions, startTime, endTime } = props;\n  let title: string = '';\n\n  const nextActions = ([] as Array<Action>).concat(initialActions).slice(0, 2);\n\n  nextActions.forEach(({ type }) => {\n    title = title ? `${title}__${type}` : type;\n  });\n\n  if (initialActions.length > 2) {\n    title = `${title}...`;\n  }\n\n  let actionColor = 'color: #7cb305; font-weight: bold';\n\n  if (title.startsWith('@init')) {\n    actionColor = 'color: #ff4d4f; font-weight: bold';\n  }\n\n  const parts = [];\n  parts.push(['action', actionColor]);\n  parts.push([title, 'color: inherit;']);\n  parts.push([\n    `@ ${formatTime(startTime)}`,\n    'color: gray; font-weight: lighter;',\n  ]);\n  parts.push([\n    `(${endTime - startTime}ms)`,\n    'color: gray; font-weight: lighter;',\n  ]);\n\n  colorGroupCollapsed(colorLog(parts));\n};\n\nconst renderSubAction = (props: {\n  type: string;\n  payload?: any;\n  actionType?: string;\n  style?: string;\n}) => {\n  const { type, payload = '', actionType = 'action', style } = props;\n  const parts = [];\n\n  if (type) {\n    parts.push([actionType, 'color: #eb2f96; font-weight: bold']);\n    parts.push([type, 'color: #722ed1; font-weight: bold']);\n  }\n\n  if (style === 'line') {\n    colorLine([...colorLog(parts), payload]);\n  } else {\n    colorGroupCollapsed([...colorLog(parts), payload]);\n  }\n};\n\nconst renderState = (state: object, isNextState: boolean = false) => {\n  const parts = [];\n\n  let title = 'currentState';\n  let style = 'color: #4CAF50; font-weight: bold';\n\n  if (isNextState) {\n    title = 'nextState';\n    style = 'color: #4CAF50; font-weight: bold';\n  }\n\n  parts.push([title, style]);\n  colorLine([...colorLog(parts), state]);\n};\n\nconst renderPrevState = (state: object) => {\n  renderState(state);\n};\n\nconst paint = (tree: {\n  type: string;\n  actions?: {\n    [key: string]: any;\n  };\n  effects?: {\n    [key: string]: any;\n  };\n  payload?: any;\n  actionType?: string;\n}) => {\n  const { type, actions = {}, effects = {}, payload, actionType } = tree;\n  const actionKeys = Object.keys(actions);\n  const effectKeys = Object.keys(effects);\n\n  if (!actionKeys.length && !effectKeys.length) {\n    renderSubAction({\n      type,\n      payload,\n      actionType,\n      style: 'line',\n    });\n  } else {\n    renderSubAction({\n      type,\n      payload,\n      actionType,\n    });\n  }\n\n  actionKeys.forEach(key => {\n    const action = actions[key];\n    paint(action);\n  });\n  effectKeys.forEach(key => {\n    const effect = effects[key];\n    paint(effect);\n  });\n\n  if (actionKeys.length || effectKeys.length) {\n    colorGroupEnd();\n  }\n};\n\nconst paintActions = (actions: Array<Action>) => {\n  const nextActions = actions.filter(({ type }) => !type.startsWith('@init'));\n\n  nextActions.forEach(action => paint(action));\n\n  if (nextActions.length) {\n    colorGroupEnd();\n  }\n};\n\nexport default (props: {\n  actions: Array<Action>;\n  prevState: object;\n  initialActions: Array<Action>;\n  startTime: number;\n  endTime: number;\n}) => {\n  const { prevState = {}, actions } = props;\n\n  renderTitle(props);\n  renderPrevState(prevState);\n  paintActions(actions);\n  colorGroupEnd();\n};\n","import { IPatcher } from './types';\n\nclass Patcher implements IPatcher {\n  public autoRunFn: Function;\n  public paths: Array<Array<string>>;\n  public removers: Array<Function>;\n  public dirty: boolean;\n  public id: string;\n  public displayName: string;\n  public parent: null | Patcher;\n  public children: Array<any>;\n\n  constructor({\n    paths,\n    autoRunFn,\n    key,\n    parent,\n    displayName,\n  }: {\n    paths: Array<Array<string>>;\n    autoRunFn: Function;\n    key: string;\n    parent: null | Patcher;\n    displayName: string;\n  }) {\n    this.autoRunFn = autoRunFn;\n    this.paths = paths;\n\n    this.removers = [];\n    this.dirty = false;\n    this.id = key;\n    this.displayName = displayName;\n    this.parent = parent;\n    this.children = [];\n\n    if (this.parent) {\n      this.parent.children.push(this);\n    }\n  }\n\n  destroyPatcher() {\n    this.teardown();\n    if (this.children.length) {\n      this.children.forEach(child => child.destroyPatcher());\n    }\n\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n    this.parent = null;\n  }\n\n  appendTo(parent: null | Patcher) {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n\n    if (parent) {\n      this.parent = parent;\n\n      if (parent.children.indexOf(this) === -1) {\n        parent.children.push(this);\n      }\n    }\n  }\n\n  belongs(parent: null | Patcher): boolean {\n    if (!parent) return false;\n\n    if (this.parent) {\n      if (this.parent === parent) {\n        return true;\n      }\n      return this.parent.belongs(parent);\n    }\n\n    return false;\n  }\n\n  removeChild(child: Patcher) {\n    const index = this.children.indexOf(child);\n    if (index !== -1) this.children.splice(index, 1);\n  }\n\n  update({ paths }: { paths: Array<Array<string>> }) {\n    this.paths = paths;\n    this.dirty = false;\n    this.teardown();\n  }\n\n  addRemover(remover: Function) {\n    this.removers.push(remover);\n  }\n\n  // 将patcher从PathNode上删除\n  teardown() {\n    this.removers.forEach(remover => remover());\n    this.removers = [];\n  }\n\n  markDirty() {\n    this.teardown();\n  }\n\n  markDirtyAll() {\n    this.teardown();\n\n    // If parent is dirty, then its children should be all dirty...\n    if (this.children.length) {\n      this.children.forEach(child => child.markDirtyAll());\n    }\n  }\n\n  triggerAutoRun() {\n    if (typeof this.autoRunFn === 'function') this.autoRunFn();\n  }\n}\n\nexport default Patcher;\n","import React, {\n  useContext,\n  useState,\n  useRef,\n  useEffect,\n  useCallback,\n  FC,\n} from 'react';\nimport context from './context';\nimport { generatePatcherKey } from './utils/key';\nimport Patcher from './Patcher';\n\nlet count = 0;\n\nconst Helper = ({ addListener }: { addListener: Function }) => {\n  addListener();\n  return null;\n};\n\nexport default (WrappedComponent: FC<any>) => {\n  function NextComponent(props: any) {\n    const shadowState = useRef(0);\n    // @ts-ignore\n    const [_, setState] = useState(0); // eslint-disable-line\n    const patcherUpdated = useRef(0);\n    const isMounted = useRef(false);\n\n    useEffect(() => {\n      isMounted.current = true;\n    });\n\n    const {\n      application,\n      useProxy,\n      useScope,\n      namespace,\n      patcher: parentPatcher,\n      useRelinkMode,\n      ...rest\n    } = useContext(context);\n\n    const incrementCount = useRef(count++)  // eslint-disable-line\n    const componentName = `${NextComponent.displayName}-${incrementCount.current}`;\n    const patcher = useRef<undefined | Patcher>();\n\n    shadowState.current += 1;\n\n    const autoRunFn = () => {\n      if (isMounted.current) setState(state => state + 1);\n    };\n\n    if (!patcher.current) {\n      patcher.current = new Patcher({\n        paths: [],\n        autoRunFn,\n        parent: parentPatcher,\n        key: generatePatcherKey({\n          namespace: namespace as string,\n          componentName,\n        }),\n        displayName: NextComponent.displayName,\n      });\n    }\n\n    application?.proxyState.enter(componentName);\n\n    useEffect(\n      () => () => {\n        if (patcher.current) patcher.current.destroyPatcher();\n      },\n      [] // eslint-disable-line\n    );\n\n    const addListener = useCallback(() => {\n      patcher.current?.appendTo(parentPatcher); // maybe not needs\n\n      // @ts-ignore\n      const paths = application?.proxyState\n        .getContext()\n        .getCurrent()\n        .getRemarkable();\n\n      patcher.current?.update({ paths: paths! });\n      if (patcher.current) application?.addPatcher(patcher.current);\n      patcherUpdated.current += 1;\n      application?.proxyState.leave();\n    }, []); // eslint-disable-line\n\n    const contextValue = {\n      ...rest,\n      application,\n      useProxy,\n      useScope,\n      namespace,\n      useRelinkMode,\n      patcher: patcher.current,\n      componentName: componentName,\n    };\n\n    return (\n      <context.Provider value={contextValue}>\n        <React.Fragment>\n          <WrappedComponent {...props} />\n          <Helper addListener={addListener} />\n        </React.Fragment>\n      </context.Provider>\n    );\n  }\n\n  NextComponent.displayName =\n    WrappedComponent.displayName ||\n    WrappedComponent.name ||\n    'ObservedComponent';\n\n  return React.memo(props => <NextComponent {...props} />);\n};\n","import React, { useRef } from 'react';\nimport context, { defaultValue } from './context';\nimport Application from './Application';\nimport { generateNamespaceKey } from './utils/key';\nimport { ProviderProps, BasicModelType } from './types';\n\n// https://fettblog.eu/typescript-react/children/\n// https://stackoverflow.com/questions/53958028/how-to-use-generics-in-props-in-react-in-a-functional-component\nfunction Provider<T extends BasicModelType<T>, K extends keyof T = keyof T>({\n  store,\n  children,\n  namespace,\n  useProxy = true,\n  useRelinkMode = true,\n  strictMode = false,\n  useScope = true,\n}: ProviderProps<T>) {\n  const namespaceRef = useRef(namespace || generateNamespaceKey());\n  const application = useRef<Application<T, K>>();\n  if (!application.current) {\n    application.current = new Application<T, K>({\n      base: store.getState() as any,\n      namespace: namespaceRef.current,\n      strictMode,\n    });\n  }\n\n  store.bindApplication(application.current);\n  const dispatch = store.dispatch;\n\n  const contextValue = useRef({\n    ...defaultValue,\n    dispatch,\n    useProxy,\n    useScope,\n    useRelinkMode,\n    namespace: namespaceRef.current,\n    application: application.current,\n  });\n\n  return (\n    <context.Provider value={contextValue.current}>{children}</context.Provider>\n  );\n}\n\nexport default Provider;\n","import compose from './utils/compose';\nimport {\n  BasicModelType,\n  CreateStoreFn,\n  CreateStoreOnlyModels,\n  Middleware,\n  UnionActions,\n} from './types';\n\nexport default function applyMiddleware(...middleware: Array<Middleware>) {\n  const nextMiddleware = [...middleware];\n  return <T extends BasicModelType<T>>(\n    createStore: CreateStoreFn<T>\n  ) => (config: {\n    models: CreateStoreOnlyModels<T>;\n    initialValue?: {\n      [key in keyof T]?: any;\n    };\n  }) => {\n    const store = createStore(config);\n    const initialState = store.getState();\n\n    const api = {\n      dispatch: (actions: UnionActions, ...rest: Array<any>) =>\n        store.dispatch(actions, ...rest),\n      getState: () => initialState,\n      store,\n    };\n\n    const chain = nextMiddleware.map(middleware => middleware<T>(api));\n    store.decorateDispatch(compose(...chain));\n\n    return store;\n  };\n}\n","// https://github.com/reduxjs/redux/blob/master/src/compose.ts\n\nexport default function compose(...funcs: Array<Function>) {\n  if (funcs.length === 0) {\n    return (arg: any) => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce((a, b) => (...args: Array<Function>) => a(b(...args)));\n}\n","import Store from './Store';\n\nimport {\n  CreateStoreOnlyModels,\n  EnhanceFunction,\n  BasicModelType,\n} from './types';\n\nexport default function createStore<\n  T extends BasicModelType<T>,\n  MODEL_KEY extends keyof T = keyof T\n>(\n  configs: {\n    models: CreateStoreOnlyModels<T>;\n    initialValue?: {\n      [key in MODEL_KEY]?: any;\n    };\n  },\n  enhancer?: EnhanceFunction\n): Store<T> {\n  if (typeof enhancer === 'function') {\n    return enhancer<T, MODEL_KEY>(createStore)(configs);\n  }\n\n  return new Store(configs);\n}\n","import print from './print';\nimport { Next, Action, ApplyMiddlewareAPI, BasicModelType } from '../../types';\n\nexport default <T extends BasicModelType<T>>({\n  getState,\n}: ApplyMiddlewareAPI<T>) => (next: Next) => (\n  actions: Array<Action> | Function\n) => {\n  if (typeof actions !== 'function') {\n    const startTime = Date.now();\n    const prevState = JSON.parse(JSON.stringify(getState()));\n\n    next(actions);\n\n    const endTime = Date.now();\n\n    print({\n      actions,\n      prevState,\n      initialActions: actions,\n      startTime,\n      endTime,\n    });\n  }\n};\n\n// 结束的时间点。。。\n// 如果同步的reducers的话，最外层运行结束就是一个结点\n// 如果说是一个effect的话，这个时候会有很多的不确定性。或者同样是以外层结束作为一个结点；\n// 然后每一次有sub结束完就搞一次；最终的结论就是一个action可能会有多个的log\n","import {\n  Next,\n  Action,\n  ThunkFn,\n  InternalDispatch,\n  ThunkDispatch,\n  BasicModelType,\n  ApplyMiddlewareAPI,\n  ExtractEffectsTypeOnlyModels,\n} from '../types';\n\n/**\n * The basic format of action type is `storeKey/${type}`.\n * Only action in effect could ignore `storeKey`\n */\nexport default <T extends BasicModelType<T>>({\n  getState,\n  dispatch,\n  store,\n}: ApplyMiddlewareAPI<T>) => (next: Next) => (\n  actions: Array<Action> | Function,\n  storeKey: keyof T\n) => {\n  if (typeof actions === 'function') {\n    const nextDispatch = (thunkActions: Array<Action> | Action) => {\n      const nextArgs = ([] as Array<Action>).concat(thunkActions) || [];\n      const actions = nextArgs\n        .map(action => {\n          if (!action) return null;\n          const { type, payload } = action;\n          const parts = [storeKey].concat(type.split('/') as any).slice(-2);\n          const nextAction: Action = {\n            type: parts.join('/'),\n          };\n          if (payload) {\n            nextAction.payload = payload;\n          }\n\n          return nextAction;\n        })\n        .filter(v => !!v) as Array<Action>;\n      if (actions.length) dispatch && (dispatch as InternalDispatch)(actions);\n    };\n    return actions(nextDispatch, getState);\n  }\n\n  const nextActions = ([] as Array<Action>).concat(actions);\n  const reducerActions: Array<Action> = [];\n  const effectActions: Array<Action> = [];\n\n  nextActions\n    .filter(action => {\n      if (Object.prototype.toString.call(action) === '[object Object]') {\n        const { type } = action;\n        return !!type;\n      }\n\n      return false;\n    })\n    .forEach(function(action: Action) {\n      try {\n        const { type } = action;\n        const parts = type.split('/');\n        const storeKey = parts[0] as keyof T;\n        const actionType = parts[1] as keyof ExtractEffectsTypeOnlyModels<\n          T\n        >[typeof storeKey];\n        const currentEffects = store.getEffects()[storeKey];\n\n        if (currentEffects && currentEffects[actionType]) {\n          return effectActions.push(action);\n        }\n\n        // If you dispatch an unregistered model's effect, it will be\n        // considered as an normal reducer action..\n        return reducerActions.push(action);\n      } catch (info) {\n        return false;\n      }\n    });\n\n  if (reducerActions.length) {\n    next(reducerActions);\n  }\n\n  effectActions.forEach(action => {\n    const { type, payload } = action;\n    const parts = type.split('/');\n    const storeKey = parts[0] as keyof T;\n    const actionType = parts[1] as keyof ExtractEffectsTypeOnlyModels<\n      T\n    >[keyof T];\n    const currentEffects = store.getEffects()[storeKey];\n    const handler = (currentEffects[actionType] as unknown) as ThunkFn<T>;\n\n    dispatch && (dispatch as ThunkDispatch<T>)(handler(payload), storeKey);\n  });\n};\n","import { useContext } from 'react';\nimport context from '../context';\nimport { ContextDefaultValue, RelinxDispatch } from '../types';\n\nexport default <T, M>(): [RelinxDispatch<T, M>] => {\n  const { dispatch } = useContext<ContextDefaultValue<T, M>>(context);\n  return [dispatch as RelinxDispatch<T, M>];\n};\n","import { useContext } from 'react';\nimport context from '../context';\n\nexport default (): string => {\n  const { namespace } = useContext(context);\n  return namespace!;\n};\n","import { useContext } from 'react';\nimport context from '../context';\nimport {\n  RelinxState,\n  RelinxDispatch,\n  UseRelinxReturnValue,\n  ContextDefaultValue,\n} from '../types';\n\nexport default <T, M, K extends keyof T = any>(\n  storeName: K\n): UseRelinxReturnValue<T, M, K> => {\n  const { dispatch, application, componentName } = useContext<\n    ContextDefaultValue<T, M>\n  >(context);\n\n  const proxyState = application?.proxyState;\n  const state = proxyState!.peek([storeName as string]);\n  const tracker = state.getTracker();\n  tracker.setContext(componentName!);\n\n  return [\n    (state as any) as RelinxState<T, M, K>,\n    dispatch as RelinxDispatch<T, M>,\n  ];\n};\n"],"names":["noop","defaultValue","computation","dispatch","attachStoreName","useProxy","namespace","patcher","trackerNode","useRelinkMode","application","Field","createContext","infoLog","args","console","log","PathNode","constructor","prop","parent","children","patchers","autoRunners","addPatcher","path","addPathNode","Patchers","destroyPatcher","addAutoRunner","autoRunner","AutoRunners","destroyAutoRunner","getCollection","field","this","handler","len","length","reduce","node","cur","index","collection","push","addRemover","indexOf","splice","err","destroyPathNode","forEach","Object","keys","key","toString","Function","call","bind","prototype","hasOwnProperty","is","x","y","Application","base","strictMode","autoRunnerNode","pendingPatchers","pendingAutoRunners","pendingCleaner","proxyState","produce","processAutoRunner","values","value","treeShakeAutoRunner","update","treeShake","updateBase","triggerAutoRun","clean","updateDryRun","actions","concat","storeKey","changedValue","relink","addPatchers","markDirty","addAutoRunners","isDirty","markClean","compare","branch","baseValue","nextValue","cb","oldValue","newValue","o2","obj","objA","objB","keysA","keysB","i","shallowEqual","isNumber","isString","isBoolean","isObject","isArray","isMutable","pathNode","paths","fullPath","getStoreData","storeName","seenKeys","MULTIPLIER","Math","pow","patcherSeenKeys","generatePatcherKey","componentName","count","AutoRunner","autoRunFn","id","_isDirty","removers","remover","teardown","autoRun","fn","invariant","state","enter","getContext","getCurrent","getRemarkable","leave","Store","configs","models","initialValue","_state","_reducers","_effects","_pendingActions","_pendingAutoRunInitializations","injectModel","_application","subscriptions","_count","getState","getReducers","getEffects","resolveActions","changedValueGroup","action","type","payload","actionType","split","usedReducer","warn","setValue","nextActions","changedValues","derivedActions","derivedChangedValue","storeSubscriptionsKeys","storeSubscriptionsKeysLength","toObject","acc","oldState","_this$_application3","newState","_this$_application4","subscription","diff","bindApplication","runPendingAutoRunInitialization","initialization","decorateDispatch","chainedMiddleware","generateSubscriptionKey","subscribe","model","reducers","effects","nextPendingActions","filter","reducer","effect","nextState","autoRunKey","modelKey","GlobalHelper","collections","addAction","actionKey","findIndex","targetNamespace","floor","random","globalHelper","padding","paddingCount","slice","formatTime","d","date","Date","hh","getHours","mm","getMinutes","ss","getSeconds","ms","getMilliseconds","colorLine","apply","colorGroupEnd","groupEnd","colorGroupCollapsed","groupCollapsed","colorLog","group","text","t","styles","s","subText","subStyle","paint","tree","actionKeys","effectKeys","props","style","parts","renderSubAction","Patcher","displayName","dirty","child","removeChild","appendTo","belongs","markDirtyAll","Helper","addListener","store","useScope","namespaceRef","useRef","undefined","isNaN","generateNamespaceKey","current","contextValue","React","context","Provider","middleware","nextMiddleware","createStore","config","initialState","api","rest","chain","map","funcs","arg","a","b","compose","enhancer","next","startTime","now","prevState","JSON","parse","stringify","initialActions","endTime","title","actionColor","startsWith","renderTitle","isNextState","renderState","paintActions","print","WrappedComponent","NextComponent","shadowState","_","setState","useState","patcherUpdated","isMounted","useEffect","parentPatcher","useContext","incrementCount","useCallback","Fragment","name","memo","thunkActions","nextAction","join","v","reducerActions","effectActions","currentEffects","info","peek","getTracker","setContext"],"mappings":"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"}