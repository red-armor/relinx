{"version":3,"file":"relinx.cjs.production.min.js","sources":["../src/context.ts","../src/PathNode.ts","../src/utils/infoLog.ts","../src/utils/toString.ts","../src/utils/shallowEqual.ts","../src/Application.ts","../src/utils/ifType.ts","../src/utils/key.ts","../src/AutoRunner.ts","../src/autoRun.ts","../src/Store.ts","../src/globalHelper.ts","../src/hooks/useGlobal.ts","../src/middleware/logger/utils.ts","../src/middleware/logger/print.ts","../src/Patcher.ts","../src/observe.tsx","../src/Provider.tsx","../src/applyMiddleware.ts","../src/utils/compose.ts","../src/createStore.ts","../src/middleware/logger/index.ts","../src/middleware/thunk.ts","../src/hooks/useDispatch.ts","../src/hooks/useNamespace.ts","../src/hooks/useRelinx.ts"],"sourcesContent":["import { createContext } from 'react';\nimport { ContextDefaultValue } from './types';\n\nconst calculateChangeBits = () => 0b00;\nconst noop = () => {};\n\nexport const defaultValue = {\n  computation: null,\n  dispatch: noop,\n  attachStoreName: noop,\n  useProxy: true,\n  namespace: null,\n  patcher: null,\n  trackerNode: null,\n  useRelinkMode: true,\n  application: null,\n};\n\n// @ts-ignore\nexport default createContext<ContextDefaultValue<T, M>>(\n  defaultValue,\n  // @ts-ignore\n  calculateChangeBits\n);\n","import infoLog from './utils/infoLog';\nimport Patcher from './Patcher';\nimport AutoRunner from './AutoRunner';\n\nconst DEBUG = false;\n\ntype Children = {\n  [key: string]: PathNode;\n};\n\ntype ToHandlerMap<T> = T extends Field.Patchers ? Patcher : AutoRunner;\n\nenum Field {\n  Patchers = 'patchers',\n  AutoRunners = 'autoRunners',\n}\n\nclass PathNode {\n  private parent: PathNode | undefined;\n  public patchers: Array<Patcher>;\n  public autoRunners: Array<AutoRunner>;\n  public children: Children;\n  private prop: string;\n\n  constructor(prop?: string, parent?: PathNode) {\n    this.prop = prop || 'root';\n\n    this.parent = parent;\n    this.children = {};\n    this.patchers = [];\n    this.autoRunners = [];\n  }\n\n  addPatcher(path: Array<string>, patcher: Patcher) {\n    this.addPathNode(path, patcher, Field.Patchers);\n  }\n\n  destroyPatcher() {}\n\n  addAutoRunner(path: Array<string>, autoRunner: AutoRunner) {\n    this.addPathNode(path, autoRunner, Field.AutoRunners);\n  }\n\n  destroyAutoRunner() {}\n\n  getCollection<T extends Field>(field: T): Array<Patcher> | Array<AutoRunner> {\n    if (field === Field.Patchers) {\n      return this.patchers;\n    }\n    return this.autoRunners;\n  }\n\n  addPathNode<T extends Field>(\n    path: Array<string>,\n    handler: ToHandlerMap<T>,\n    field: T\n  ) {\n    try {\n      const len = path.length;\n      path.reduce<PathNode>((node: PathNode, cur: string, index: number) => {\n        // path中前面的值都是为了让我们定位到最后的需要关心的位置\n        if (!node.children[cur]) node.children[cur] = new PathNode(cur, node);\n        // 只有到达`path`的最后一个`prop`时，才会进行patcher的添加\n        if (index === len - 1) {\n          const childNode = node.children[cur];\n          if (DEBUG) {\n            infoLog('[PathNode add handler]', childNode, handler);\n          }\n          const collection = childNode.getCollection(field) as Array<\n            ToHandlerMap<T>\n          >;\n\n          if (collection) {\n            collection.push(handler);\n            handler.addRemover(() => {\n              const index = collection.indexOf(handler);\n\n              if (DEBUG) {\n                infoLog('[PathNode remove handler]', handler.id, childNode);\n              }\n              if (index !== -1) {\n                collection.splice(index, 1);\n              }\n            });\n          }\n        }\n        return node.children[cur];\n      }, this);\n    } catch (err) {\n      // console.log('err ', err)\n    }\n  }\n\n  destroyPathNode() {\n    try {\n      this.patchers.forEach(patcher => patcher.destroyPatcher());\n\n      if (this.children) {\n        const childKeys = Object.keys(this.children);\n        childKeys.forEach(key => {\n          const pathNode = this.children[key];\n          pathNode.destroyPathNode();\n        });\n      }\n\n      if (this.parent) {\n        delete this.parent.children[this.prop];\n      }\n    } catch (err) {\n      infoLog('[PathNode destroy issue]', err);\n    }\n  }\n}\n\nexport default PathNode;\n","/**\n * Intentional info-level logging for clear separation from ad-hoc console debug logging.\n */\nfunction infoLog(...args: Array<any>) {\n  console.log('**DEBUG**', ...args); // eslint-disable-line\n}\n\nexport default infoLog;\n","const toString = Function.call.bind(Object.prototype.toString);\n\nexport default toString;\n","// https://github.com/facebook/react/blob/144328fe81719e916b946e22660479e31561bb0b/packages/shared/shallowEqual.js#L36-L68\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/* eslint-disable no-self-compare */\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x: any, y: any) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  }\n  // Step 6.a: NaN == NaN\n  return x !== x && y !== y;\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA: any, objB: any) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !hasOwnProperty.call(objB, keysA[i]) ||\n      !is(objA[keysA[i]], objB[keysA[i]])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport default shallowEqual;\n","import PathNode from './PathNode';\nimport infoLog from './utils/infoLog';\nimport { isTypeEqual, isPrimitive, isMutable } from './utils/ifType';\nimport shallowEqual from './utils/shallowEqual';\nimport {\n  Action,\n  IApplication,\n  GenericState,\n  PendingPatcher,\n  PendingAutoRunner,\n  ChangedValueGroup,\n} from './types';\nimport Patcher from './Patcher';\nimport produce, { ProxyState } from 'state-tracker';\nimport AutoRunner from './AutoRunner';\n\nclass Application<T, K extends keyof T> implements IApplication<T, K> {\n  public base: GenericState<T, K>;\n  public node: PathNode;\n  public autoRunnerNode: PathNode;\n  public pendingPatchers: Array<PendingPatcher>;\n  public pendingAutoRunners: Array<PendingAutoRunner>;\n  public pendingCleaner: Array<Function>;\n  public namespace: string;\n  public strictMode: boolean;\n  public proxyState: ProxyState;\n\n  constructor({\n    base,\n    namespace,\n    strictMode,\n  }: {\n    base: GenericState<T, K>;\n    namespace: string;\n    strictMode: boolean;\n  }) {\n    this.base = base;\n    this.node = new PathNode();\n    this.autoRunnerNode = new PathNode();\n    this.pendingPatchers = [];\n    this.pendingAutoRunners = [];\n    this.pendingCleaner = [];\n    this.namespace = namespace;\n    this.strictMode = strictMode;\n    this.proxyState = produce(this.base);\n  }\n\n  processAutoRunner(values: Array<ChangedValueGroup<K>>) {\n    this.pendingAutoRunners = [];\n\n    try {\n      values.forEach(value => this.treeShakeAutoRunner(value));\n    } catch (err) {\n      infoLog('[Application] processAutoRunner issue ', err);\n    }\n  }\n\n  update(values: Array<ChangedValueGroup<K>>) {\n    try {\n      values.forEach(value => this.treeShake(value));\n      values.forEach(value => this.updateBase(value));\n    } catch (err) {\n      infoLog('[Application] update issue ', err);\n    }\n\n    this.pendingPatchers.forEach(({ patcher }) => {\n      patcher.triggerAutoRun();\n    });\n    this.pendingPatchers = [];\n\n    this.pendingAutoRunners = [];\n\n    this.pendingCleaner.forEach(clean => clean());\n    this.pendingCleaner = [];\n  }\n\n  updateDryRun(values: Array<ChangedValueGroup<K>>): Array<Action> {\n    let actions = [] as Array<Action>;\n\n    try {\n      values.forEach(value => this.treeShake(value));\n      this.processAutoRunner(values);\n      values.forEach(value => this.updateBase(value));\n      this.pendingAutoRunners.forEach(({ autoRunner }) => {\n        actions = actions.concat(autoRunner.triggerAutoRun());\n      });\n    } catch (err) {\n      infoLog('[Application] update issue ', err);\n    }\n\n    return actions;\n  }\n\n  updateBase({\n    storeKey,\n    changedValue,\n  }: {\n    storeKey: K;\n    changedValue: object;\n  }) {\n    const origin = this.base[storeKey] || ({} as any);\n    this.proxyState.relink([storeKey as string], {\n      ...origin,\n      ...changedValue,\n    });\n  }\n\n  addPatchers(patchers: Array<Patcher>) {\n    if (patchers.length) {\n      patchers.forEach(patcher => {\n        this.pendingPatchers.push({ patcher });\n      });\n      patchers.forEach(patcher => {\n        patcher.markDirty();\n      });\n    }\n  }\n\n  addAutoRunners(autoRunners: Array<AutoRunner>) {\n    if (autoRunners.length) {\n      autoRunners.forEach(autoRunner => {\n        if (!autoRunner.isDirty()) {\n          this.pendingAutoRunners.push({ autoRunner });\n          this.pendingCleaner.push(autoRunner.markClean.bind(autoRunner));\n        }\n      });\n      autoRunners.forEach(autoRunner => {\n        autoRunner.markDirty();\n      });\n    }\n  }\n\n  compare(\n    branch: PathNode,\n    baseValue: {\n      [key: string]: any;\n    },\n    nextValue: {\n      [key: string]: any;\n    },\n    cb: {\n      (pathNode: PathNode): void;\n    }\n  ) {\n    const keysToCompare = Object.keys(branch.children);\n\n    keysToCompare.forEach(key => {\n      const oldValue = baseValue[key];\n      const newValue = nextValue[key];\n\n      if (shallowEqual(oldValue, newValue)) return;\n\n      if (isTypeEqual(oldValue, newValue)) {\n        if (isPrimitive(newValue)) {\n          if (oldValue !== newValue) {\n            cb(branch.children[key]);\n            // this.addPatchers(branch.children[key].patchers);\n          }\n        }\n\n        if (isMutable(newValue)) {\n          const childBranch = branch.children[key];\n          this.compare(childBranch, oldValue, newValue, cb);\n          return;\n        }\n\n        return;\n      }\n      cb(branch.children[key]);\n      // this.addPatchers(branch.children[key].patchers);\n    });\n  }\n\n  treeShakeAutoRunner({\n    storeKey,\n    changedValue,\n  }: {\n    storeKey: K;\n    changedValue: object;\n  }) {\n    const branch = this.autoRunnerNode.children[storeKey as any];\n    const baseValue = this.base[storeKey];\n    const nextValue = { ...baseValue, ...changedValue };\n\n    // why it could be undefined. please refer to https://github.com/ryuever/relinx/issues/4\n    if (!branch) return;\n    this.compare(branch, baseValue, nextValue, (pathNode: PathNode) => {\n      this.addAutoRunners(pathNode.autoRunners);\n    });\n  }\n\n  /**\n   *\n   * Recently it only support `Array`, `Object`, `Number`, `String` and `Boolean` five\n   * types..\n   */\n  treeShake({ storeKey, changedValue }: { storeKey: K; changedValue: object }) {\n    const branch = this.node.children[storeKey as any];\n    const baseValue = this.base[storeKey];\n    const nextValue = { ...baseValue, ...changedValue };\n\n    // why it could be undefined. please refer to https://github.com/ryuever/relinx/issues/4\n    if (!branch) return;\n    this.compare(branch, baseValue, nextValue, (pathNode: PathNode) => {\n      this.addPatchers(pathNode.patchers);\n    });\n  }\n\n  addPatcher(patcher: Patcher) {\n    const paths = patcher.paths;\n\n    paths.forEach(fullPath => {\n      this.node.addPatcher(fullPath, patcher);\n    });\n  }\n\n  addAutoRunner(autoRunner: AutoRunner) {\n    const paths = autoRunner.paths;\n    paths.forEach(fullPath => {\n      this.autoRunnerNode.addAutoRunner(fullPath, autoRunner);\n    });\n  }\n\n  getStoreData(storeName: K): T[K] {\n    const storeValue = this.base[storeName];\n    return storeValue;\n  }\n}\n\nexport default Application;\n","import toString from './toString';\n\nexport const isPresent = (o: any) => typeof o !== 'undefined';\nexport const isObject = (obj: any) => toString(obj) === '[object Object]';\nexport const isArray = (obj: any) => toString(obj) === '[object Array]';\nexport const isNumber = (obj: any) => toString(obj) === '[object Number]';\nexport const isString = (obj: any) => toString(obj) === '[object String]';\nexport const isBoolean = (obj: any) => toString(obj) === '[object Boolean]';\n\nexport const isMutable = (obj: any) => isObject(obj) || isArray(obj);\nexport const isPrimitive = (obj: any) =>\n  isNumber(obj) || isString(obj) || isBoolean(obj);\nexport const isTypeEqual = (o1: any, o2: any) => toString(o1) === toString(o2);\n\nexport const isStrictEmptyObject = (obj: any) => {\n  if (!isObject(obj)) return false;\n\n  for (const prop in obj) { // eslint-disable-line\n    if (obj.hasOwnProperty(prop)) return false // eslint-disable-line\n  }\n  return true;\n};\n\nexport const isStrictEmptyArray = (arr: any) => isArray(arr) && !arr.length;\n\nexport const hasEmptyItem = (...args: Array<any>) =>\n  args.some(arg => isStrictEmptyArray(arg) || isStrictEmptyObject(arg));\n","// https://github.com/facebook/draft-js/blob/master/src/model/keys/generateRandomKey.js\n\ninterface SeenKeys {\n  [key: string]: boolean;\n}\n\ninterface PatcherIds {\n  [key: string]: number;\n}\n\ninterface PatcherSeenKeys {\n  [key: string]: {\n    [key: string]: number;\n  };\n}\n\nconst seenKeys: SeenKeys = {};\nconst MULTIPLIER = Math.pow(2, 24) // eslint-disable-line\n\nexport const generateNamespaceKey = () => {\n  let key;\n\n  while (key === undefined || seenKeys.hasOwnProperty(key) || !isNaN(+key)) { // eslint-disable-line\n    key = Math.floor(Math.random() * MULTIPLIER).toString(32);\n  }\n\n  seenKeys[key] = true;\n  return key;\n};\n\nconst patcherIds: PatcherIds = {};\nexport const generatePatcherId = ({\n  namespace,\n}: {\n  namespace: string;\n}): string => {\n  const count = patcherIds[namespace] || 0;\n  const next = count + 1;\n  patcherIds[namespace] = next;\n  return `${namespace}_patcherId_${count}`;\n};\n\nconst patcherSeenKeys: PatcherSeenKeys = {};\nexport const generatePatcherKey = ({\n  namespace,\n  componentName,\n}: {\n  namespace: string;\n  componentName: string;\n}) => {\n  if (!patcherSeenKeys[namespace]) patcherSeenKeys[namespace] = {};\n  const count = patcherSeenKeys[namespace][componentName] || 0;\n  const next = count + 1;\n  patcherSeenKeys[namespace][componentName] = next;\n  return `${namespace}_${componentName}_patcher_${count}`;\n};\n\nexport const generateRandomGlobalActionKey = () => Math.floor(Math.random() * MULTIPLIER).toString(32) // eslint-disable-line\n","import { AutoRunnerProps, Action } from './types';\n\nlet count = 1;\nclass AutoRunner {\n  private _isDirty: boolean;\n  public paths: Array<Array<string>>;\n  public autoRunFn: Function;\n  public id: string;\n  public removers: Array<Function>;\n  public modelKey: string;\n\n  constructor({ paths, autoRunFn, modelKey }: AutoRunnerProps) {\n    this.id = `autoRunner_${count++}`;\n    this.paths = paths;\n    this.autoRunFn = autoRunFn;\n    this._isDirty = false;\n    this.removers = [];\n    this.modelKey = modelKey;\n  }\n\n  addRemover(remover: Function) {\n    this.removers.push(remover);\n  }\n\n  teardown() {\n    this.removers.forEach(remover => remover());\n    this.removers = [];\n  }\n\n  markDirty() {\n    this._isDirty = true;\n  }\n\n  markClean() {\n    this._isDirty = false;\n  }\n\n  isDirty(): boolean {\n    return this._isDirty;\n  }\n\n  triggerAutoRun() {\n    const actions = (this.autoRunFn() || []) as Array<Action>;\n    return actions.map(action => {\n      const { type, payload } = action;\n      // if type is not in `namespace/type` format, then add modelKey as default namespace.\n      if (!/\\//.test(type)) {\n        return {\n          type: `${this.modelKey}/${type}`,\n          payload,\n        };\n      }\n      return action;\n    });\n  }\n}\n\nexport default AutoRunner;\n","import invariant from 'invariant';\nimport Application from './Application';\nimport AutoRunner from './AutoRunner';\n\nconst autoRun = <T, K extends keyof T>(\n  fn: Function,\n  application: Application<T, K>,\n  modelKey: string\n) => {\n  invariant(application, 'application is required to be initialized already !');\n\n  const state = application.proxyState;\n\n  state.enter();\n  fn({ state });\n  const tracker = state.getContext().getCurrent();\n  const paths = tracker.getRemarkable();\n\n  const autoRunner = new AutoRunner({\n    paths,\n    modelKey,\n    autoRunFn: () => {\n      return fn({ state });\n    },\n  });\n\n  application.addAutoRunner(autoRunner);\n\n  state.leave();\n};\n\nexport default autoRun;\n","import Application from './Application';\nimport {\n  Action,\n  InternalDispatch,\n  Subscription,\n  BasicModelType,\n  AutoRunSubscriptions,\n  ChangedValueGroup,\n  CreateStoreOnlyModels,\n  ExtractStateTypeOnlyModels,\n  ExtractEffectsTypeOnlyModels,\n  ExtractReducersTypeOnlyModels,\n  PendingAutoRunInitialization,\n} from './types';\nimport autoRun from './autoRun';\n\nclass Store<T extends BasicModelType<T>, MODEL_KEY extends keyof T = keyof T> {\n  private _application: Application<T, MODEL_KEY> | null;\n  private _count: number;\n  public dispatch: InternalDispatch;\n  private _state: ExtractStateTypeOnlyModels<T>;\n  private _reducers: ExtractReducersTypeOnlyModels<T>;\n  private _effects: ExtractEffectsTypeOnlyModels<T>;\n  private _pendingAutoRunInitializations: Array<PendingAutoRunInitialization>;\n  private _pendingActions: Array<Action>;\n  public initialState: any;\n  public subscriptions: {\n    [key: string]: Subscription<ExtractStateTypeOnlyModels<T>>;\n  };\n\n  constructor(configs: {\n    models: CreateStoreOnlyModels<T>;\n    initialValue?: {\n      [key in MODEL_KEY]?: any;\n    };\n  }) {\n    const models = configs.models;\n    const initialValue = configs.initialValue || ({} as any);\n\n    this._state = {} as ExtractStateTypeOnlyModels<T>;\n    this._reducers = {} as ExtractReducersTypeOnlyModels<T>;\n    this._effects = {} as ExtractEffectsTypeOnlyModels<T>;\n    this._pendingActions = [];\n    this._pendingAutoRunInitializations = [];\n\n    const keys = Object.keys(models) as Array<MODEL_KEY>;\n\n    keys.forEach(key => {\n      this.injectModel(key, models[key], initialValue[key]);\n    });\n\n    this.dispatch = () => {};\n    this._application = null;\n    this.subscriptions = {};\n    this._count = 0;\n  }\n\n  getState(): ExtractStateTypeOnlyModels<T> {\n    return this._state;\n  }\n\n  getReducers(): ExtractReducersTypeOnlyModels<T> {\n    return this._reducers;\n  }\n\n  getEffects(): ExtractEffectsTypeOnlyModels<T> {\n    return this._effects;\n  }\n\n  resolveActions(actions: Array<Action>) {\n    return actions.reduce<Array<ChangedValueGroup<MODEL_KEY>>>(\n      (changedValueGroup, action) => {\n        if (!this._application) return [];\n        const { type, payload } = action;\n        const [storeKey, actionType] = type.split('/') as [\n          MODEL_KEY,\n          keyof ExtractReducersTypeOnlyModels<T>\n        ];\n        const usedReducer = this._reducers[storeKey];\n\n        // If usedReducer is null, Maybe you have dispatched an unregistered action.\n        // On this condition, put these actions to `this._pendingActions`\n        if (!usedReducer) {\n          this._pendingActions.push(action);\n        } else if (usedReducer[actionType]) {\n          const currentState = this._application.base[storeKey];\n          const changedValue = usedReducer[actionType](currentState, payload);\n          changedValueGroup.push({\n            storeKey,\n            changedValue,\n          });\n        } else {\n          console.warn(`Do not have action '${actionType}'`);\n        }\n\n        return changedValueGroup;\n      },\n      []\n    );\n  }\n\n  setValue(actions: Array<Action>) {\n    const nextActions = ([] as Array<Action>).concat(actions);\n    const changedValues = this.resolveActions(nextActions);\n\n    if (changedValues.length) {\n      // updateDryRun do two things\n      // 1. resolve pendingPatchers\n      // 2. assign application.base with new value.\n      // Note: on this step, pendingPatchers do not execute\n      const derivedActions =\n        this._application?.updateDryRun(changedValues) || [];\n      // model.subscriptions may cause new value update..\n      const derivedChangedValue = this.resolveActions(derivedActions!);\n      this._application?.update(derivedChangedValue);\n\n      const storeSubscriptionsKeys = Object.keys(this.subscriptions);\n      const storeSubscriptionsKeysLength = storeSubscriptionsKeys.length;\n      // Only if there are store subscriptions. it requires to calculate old and new value..\n      if (storeSubscriptionsKeysLength) {\n        const toObject = changedValues.reduce<\n          {\n            [key in MODEL_KEY]: object;\n          }\n        >(\n          (acc, cur) => {\n            const { storeKey, changedValue } = cur;\n            acc[storeKey] = {\n              ...acc[storeKey],\n              ...changedValue,\n            };\n            return acc;\n          },\n          {} as {\n            [key in MODEL_KEY]: object;\n          }\n        );\n        const oldState = {\n          ...this._application?.base,\n        } as ExtractStateTypeOnlyModels<T>;\n        const newState = {\n          ...this._application?.base,\n          ...toObject,\n        } as ExtractStateTypeOnlyModels<T>;\n        for (let i = 0; i < storeSubscriptionsKeysLength; i++) {\n          const key = storeSubscriptionsKeys[i];\n          const subscription = this.subscriptions[key];\n          subscription({\n            oldState,\n            newState,\n            diff: toObject as Partial<ExtractStateTypeOnlyModels<T>>,\n          });\n        }\n      }\n    }\n  }\n\n  bindApplication(application: Application<T, MODEL_KEY>) {\n    this._application = application;\n    this.runPendingAutoRunInitialization();\n  }\n\n  runPendingAutoRunInitialization() {\n    if (this._pendingAutoRunInitializations.length) {\n      this._pendingAutoRunInitializations.forEach(initialization => {\n        const { autoRunFn, modelKey } = initialization;\n        autoRun(autoRunFn, this._application!, modelKey);\n      });\n      this._pendingAutoRunInitializations = [];\n    }\n  }\n\n  decorateDispatch(chainedMiddleware: Function) {\n    this.dispatch = chainedMiddleware(this.setValue.bind(this));\n  }\n\n  generateSubscriptionKey(): string {\n    return `store_${this._count++}`;\n  }\n\n  subscribe(\n    subscription: Subscription<ExtractStateTypeOnlyModels<T>>\n  ): Function {\n    const key = this.generateSubscriptionKey();\n    this.subscriptions[key] = subscription;\n    return () => delete this.subscriptions[key];\n  }\n\n  injectModel(key: MODEL_KEY, model: any, initialValue: any = {}) {\n    const { state, reducers = {}, effects = {} } = model;\n    const subscriptions = model.subscriptions || ({} as AutoRunSubscriptions);\n    // consume all the pending actions.\n    let base = this._application?.getStoreData(key) || {\n      ...state,\n      ...initialValue,\n    };\n\n    const nextPendingActions = this._pendingActions.filter(action => {\n      const { type, payload } = action;\n      const [storeKey, actionType] = type.split('/') as [\n        MODEL_KEY,\n        keyof ExtractReducersTypeOnlyModels<T>\n      ];\n\n      // only process action with current injected model's tag\n      if (key === storeKey) {\n        const reducer = reducers[actionType];\n        const effect = effects[actionType];\n\n        let nextState = base;\n\n        if (typeof reducer === 'function') {\n          nextState = reducer(base, payload);\n          base = { ...base, ...nextState };\n          // what if pending action is an effect. call dispatch again to re-run...\n          // But, there is still a condition, effects followed by normal reducer...\n          // The result may override by effect...\n        } else if (typeof effect === 'function') {\n          this.dispatch(action);\n        } else {\n          console.warn(\n            `Maybe you have dispatched an unregistered model's effect action(${action})`\n          );\n        }\n      }\n\n      return storeKey !== key;\n    });\n\n    const subscriptionsKeys = Object.keys(subscriptions);\n    subscriptionsKeys.forEach(autoRunKey => {\n      const autoRunFn = subscriptions[autoRunKey];\n\n      if (!this._application) {\n        this._pendingAutoRunInitializations.push({\n          modelKey: key as string,\n          autoRunKey,\n          autoRunFn,\n        });\n      } else {\n        autoRun<T, MODEL_KEY>(autoRunFn, this._application, key as string);\n      }\n    });\n\n    this._state[key] = base;\n    this._pendingActions = nextPendingActions;\n\n    this._application?.updateBase({\n      storeKey: key,\n      changedValue: base,\n    });\n\n    if (reducers) this._reducers[key] = reducers as any;\n    if (effects) this._effects[key] = effects as any;\n  }\n}\n\nexport default Store;\n","import { Collections, Action } from './types';\n\nclass GlobalHelper {\n  public collections: Collections;\n  constructor() {\n    this.collections = [];\n  }\n\n  addAction(actionKey: string, namespace: string, actions: Array<Action>) {\n    this.collections.push({\n      actionKey,\n      namespace,\n      remover: () => {\n        const index = this.collections.findIndex(\n          ({ actionKey: key }) => key === actionKey\n        );\n        if (index !== -1) this.collections.splice(index, 1);\n      },\n      actions,\n    });\n  }\n}\n\nexport default new GlobalHelper();\n","import invariant from 'invariant';\nimport globalHelper from '../globalHelper';\nimport { generateRandomGlobalActionKey } from '../utils/key';\nimport {\n  GlobalActions,\n  GlobalAction,\n  GlobalDispatch,\n  Collections,\n} from '../types';\n\nconst dispatch = (actions: GlobalActions | GlobalAction) => {\n  const next = ([] as GlobalActions).concat(actions);\n\n  next.forEach(action => {\n    const { namespace: targetNamespace, actions } = action;\n    invariant(targetNamespace, '`namespace` is required for global action');\n    invariant(actions, '`actions` is required for global action');\n    const actionKey = generateRandomGlobalActionKey();\n    globalHelper.addAction(actionKey, targetNamespace, actions);\n  });\n};\n\n// It is not a official documentation compatible Hooks API.\n// For global state, data change responsive is not required, which means\n// value's change will not trigger any UI/data update...\nexport default (): [Collections, GlobalDispatch] => [\n  globalHelper.collections,\n  dispatch,\n];\n","const padding = (value: number, paddingCount = 2) =>\n  `00${value}`.slice(-paddingCount);\n\nexport const formatTime = (d: number) => {\n  const date = new Date(d);\n  const hh = date.getHours();\n  const mm = date.getMinutes();\n  const ss = date.getSeconds();\n  const ms = date.getMilliseconds();\n\n  return `${padding(hh)}:${padding(mm)}:${padding(ss)}.${padding(ms, 3)}`;\n};\n","import { Action } from '../../types';\n\nimport { formatTime } from './utils';\n\nconst colorLine = Function.apply.bind(console.log, null) // eslint-disable-line\nconst colorGroupEnd = console.groupEnd // eslint-disable-line\nconst colorGroupCollapsed = Function.apply.bind(console.groupCollapsed, null) // eslint-disable-line\n// const isEmptyObject = obj => !obj || Object.keys(obj).length === 0 && obj.constructor === Object\n\nconst colorLog = (group: Array<Array<string>>) => {\n  const { text: t, styles: s } = group.reduce(\n    (acc, cur) => {\n      const { text, styles } = acc;\n      const [subText, subStyle] = cur;\n\n      return {\n        text: `${text}%c ${subText}`,\n        styles: ([] as Array<string>).concat(styles, subStyle),\n      };\n    },\n    {\n      text: '',\n      styles: [] as Array<string>,\n    }\n  );\n\n  return [t, ...s];\n};\n\nconst renderTitle = (props: {\n  initialActions: Array<Action>;\n  startTime: number;\n  endTime: number;\n}) => {\n  const { initialActions, startTime, endTime } = props;\n  let title: string = '';\n\n  const nextActions = ([] as Array<Action>).concat(initialActions).slice(0, 2);\n\n  nextActions.forEach(({ type }) => {\n    title = title ? `${title}__${type}` : type;\n  });\n\n  if (initialActions.length > 2) {\n    title = `${title}...`;\n  }\n\n  let actionColor = 'color: #7cb305; font-weight: bold';\n\n  if (title.startsWith('@init')) {\n    actionColor = 'color: #ff4d4f; font-weight: bold';\n  }\n\n  const parts = [];\n  parts.push(['action', actionColor]);\n  parts.push([title, 'color: inherit;']);\n  parts.push([\n    `@ ${formatTime(startTime)}`,\n    'color: gray; font-weight: lighter;',\n  ]);\n  parts.push([\n    `(${endTime - startTime}ms)`,\n    'color: gray; font-weight: lighter;',\n  ]);\n\n  colorGroupCollapsed(colorLog(parts));\n};\n\nconst renderSubAction = (props: {\n  type: string;\n  payload?: any;\n  actionType?: string;\n  style?: string;\n}) => {\n  const { type, payload = '', actionType = 'action', style } = props;\n  const parts = [];\n\n  if (type) {\n    parts.push([actionType, 'color: #eb2f96; font-weight: bold']);\n    parts.push([type, 'color: #722ed1; font-weight: bold']);\n  }\n\n  if (style === 'line') {\n    colorLine([...colorLog(parts), payload]);\n  } else {\n    colorGroupCollapsed([...colorLog(parts), payload]);\n  }\n};\n\nconst renderState = (state: object, isNextState: boolean = false) => {\n  const parts = [];\n\n  let title = 'currentState';\n  let style = 'color: #4CAF50; font-weight: bold';\n\n  if (isNextState) {\n    title = 'nextState';\n    style = 'color: #4CAF50; font-weight: bold';\n  }\n\n  parts.push([title, style]);\n  colorLine([...colorLog(parts), state]);\n};\n\nconst renderPrevState = (state: object) => {\n  renderState(state);\n};\n\nconst paint = (tree: {\n  type: string;\n  actions?: {\n    [key: string]: any;\n  };\n  effects?: {\n    [key: string]: any;\n  };\n  payload?: any;\n  actionType?: string;\n}) => {\n  const { type, actions = {}, effects = {}, payload, actionType } = tree;\n  const actionKeys = Object.keys(actions);\n  const effectKeys = Object.keys(effects);\n\n  if (!actionKeys.length && !effectKeys.length) {\n    renderSubAction({\n      type,\n      payload,\n      actionType,\n      style: 'line',\n    });\n  } else {\n    renderSubAction({\n      type,\n      payload,\n      actionType,\n    });\n  }\n\n  actionKeys.forEach(key => {\n    const action = actions[key];\n    paint(action);\n  });\n  effectKeys.forEach(key => {\n    const effect = effects[key];\n    paint(effect);\n  });\n\n  if (actionKeys.length || effectKeys.length) {\n    colorGroupEnd();\n  }\n};\n\nconst paintActions = (actions: Array<Action>) => {\n  const nextActions = actions.filter(({ type }) => !type.startsWith('@init'));\n\n  nextActions.forEach(action => paint(action));\n\n  if (nextActions.length) {\n    colorGroupEnd();\n  }\n};\n\nexport default (props: {\n  actions: Array<Action>;\n  prevState: object;\n  initialActions: Array<Action>;\n  startTime: number;\n  endTime: number;\n}) => {\n  const { prevState = {}, actions } = props;\n\n  renderTitle(props);\n  renderPrevState(prevState);\n  paintActions(actions);\n  colorGroupEnd();\n};\n","import { IPatcher } from './types';\n\nclass Patcher implements IPatcher {\n  public autoRunFn: Function;\n  public paths: Array<Array<string>>;\n  public removers: Array<Function>;\n  public dirty: boolean;\n  public id: string;\n  public displayName: string;\n  public parent: null | Patcher;\n  public children: Array<any>;\n\n  constructor({\n    paths,\n    autoRunFn,\n    key,\n    parent,\n    displayName,\n  }: {\n    paths: Array<Array<string>>;\n    autoRunFn: Function;\n    key: string;\n    parent: null | Patcher;\n    displayName: string;\n  }) {\n    this.autoRunFn = autoRunFn;\n    this.paths = paths;\n\n    this.removers = [];\n    this.dirty = false;\n    this.id = key;\n    this.displayName = displayName;\n    this.parent = parent;\n    this.children = [];\n\n    if (this.parent) {\n      this.parent.children.push(this);\n    }\n  }\n\n  destroyPatcher() {\n    this.teardown();\n    if (this.children.length) {\n      this.children.forEach(child => child.destroyPatcher());\n    }\n\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n    this.parent = null;\n  }\n\n  appendTo(parent: null | Patcher) {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n\n    if (parent) {\n      this.parent = parent;\n\n      if (parent.children.indexOf(this) === -1) {\n        parent.children.push(this);\n      }\n    }\n  }\n\n  belongs(parent: null | Patcher): boolean {\n    if (!parent) return false;\n\n    if (this.parent) {\n      if (this.parent === parent) {\n        return true;\n      }\n      return this.parent.belongs(parent);\n    }\n\n    return false;\n  }\n\n  removeChild(child: Patcher) {\n    const index = this.children.indexOf(child);\n    if (index !== -1) this.children.splice(index, 1);\n  }\n\n  update({ paths }: { paths: Array<Array<string>> }) {\n    this.paths = paths;\n    this.dirty = false;\n    this.teardown();\n  }\n\n  addRemover(remover: Function) {\n    this.removers.push(remover);\n  }\n\n  // 将patcher从PathNode上删除\n  teardown() {\n    this.removers.forEach(remover => remover());\n    this.removers = [];\n  }\n\n  markDirty() {\n    this.teardown();\n  }\n\n  markDirtyAll() {\n    this.teardown();\n\n    // If parent is dirty, then its children should be all dirty...\n    if (this.children.length) {\n      this.children.forEach(child => child.markDirtyAll());\n    }\n  }\n\n  triggerAutoRun() {\n    if (typeof this.autoRunFn === 'function') this.autoRunFn();\n  }\n}\n\nexport default Patcher;\n","import React, {\n  useContext,\n  useState,\n  useRef,\n  useEffect,\n  useCallback,\n  FC,\n} from 'react';\nimport context from './context';\nimport { generatePatcherKey } from './utils/key';\nimport Patcher from './Patcher';\n\nlet count = 0;\n\nconst Helper = ({ addListener }: { addListener: Function }) => {\n  addListener();\n  return null;\n};\n\nexport default (WrappedComponent: FC<any>) => {\n  function NextComponent(props: any) {\n    const shadowState = useRef(0);\n    // @ts-ignore\n    const [_, setState] = useState(0); // eslint-disable-line\n    const patcherUpdated = useRef(0);\n    const isMounted = useRef(false);\n    const { $_modelKey, ...restProps } = props;\n\n    useEffect(() => {\n      isMounted.current = true;\n    });\n\n    const {\n      application,\n      useProxy,\n      useScope,\n      namespace,\n      patcher: parentPatcher,\n      useRelinkMode,\n      ...rest\n    } = useContext(context);\n\n    const incrementCount = useRef(count++)  // eslint-disable-line\n    const componentName = `${NextComponent.displayName}-${incrementCount.current}`;\n    const patcher = useRef<undefined | Patcher>();\n\n    shadowState.current += 1;\n\n    const autoRunFn = () => {\n      if (isMounted.current) setState(state => state + 1);\n    };\n\n    if (!patcher.current) {\n      patcher.current = new Patcher({\n        paths: [],\n        autoRunFn,\n        parent: parentPatcher,\n        key: generatePatcherKey({\n          namespace: namespace as string,\n          componentName,\n        }),\n        displayName: NextComponent.displayName,\n      });\n    }\n\n    application?.proxyState.enter(componentName);\n\n    useEffect(\n      () => () => {\n        if (patcher.current) patcher.current.destroyPatcher();\n      },\n      [] // eslint-disable-line\n    );\n\n    const addListener = useCallback(() => {\n      patcher.current?.appendTo(parentPatcher); // maybe not needs\n\n      // @ts-ignore\n      const paths = application?.proxyState\n        .getContext()\n        .getCurrent()\n        .getRemarkable();\n\n      patcher.current?.update({ paths: paths! });\n      if (patcher.current) application?.addPatcher(patcher.current);\n      patcherUpdated.current += 1;\n      application?.proxyState.leave();\n    }, []); // eslint-disable-line\n\n    const contextValue = {\n      ...rest,\n      application,\n      useProxy,\n      useScope,\n      namespace,\n      useRelinkMode,\n      patcher: patcher.current,\n      componentName: componentName,\n    };\n\n    if ($_modelKey) {\n      contextValue.$_modelKey = $_modelKey;\n    }\n\n    return (\n      <context.Provider value={contextValue}>\n        <React.Fragment>\n          <WrappedComponent {...restProps} />\n          <Helper addListener={addListener} />\n        </React.Fragment>\n      </context.Provider>\n    );\n  }\n\n  NextComponent.displayName =\n    WrappedComponent.displayName ||\n    WrappedComponent.name ||\n    'ObservedComponent';\n\n  return React.memo(props => <NextComponent {...props} />);\n};\n","import React, { useRef } from 'react';\nimport context, { defaultValue } from './context';\nimport Application from './Application';\nimport { generateNamespaceKey } from './utils/key';\nimport { ProviderProps, BasicModelType } from './types';\n\n// https://fettblog.eu/typescript-react/children/\n// https://stackoverflow.com/questions/53958028/how-to-use-generics-in-props-in-react-in-a-functional-component\nfunction Provider<T extends BasicModelType<T>, K extends keyof T = keyof T>({\n  store,\n  children,\n  namespace,\n  useProxy = true,\n  useRelinkMode = true,\n  strictMode = false,\n  useScope = true,\n}: ProviderProps<T>) {\n  const namespaceRef = useRef(namespace || generateNamespaceKey());\n  const application = useRef<Application<T, K>>();\n  if (!application.current) {\n    application.current = new Application<T, K>({\n      base: store.getState() as any,\n      namespace: namespaceRef.current,\n      strictMode,\n    });\n  }\n\n  store.bindApplication(application.current);\n  const dispatch = store.dispatch;\n\n  const contextValue = useRef({\n    ...defaultValue,\n    dispatch,\n    useProxy,\n    useScope,\n    useRelinkMode,\n    namespace: namespaceRef.current,\n    application: application.current,\n  });\n\n  return (\n    <context.Provider value={contextValue.current}>{children}</context.Provider>\n  );\n}\n\nexport default Provider;\n","import compose from './utils/compose';\nimport {\n  BasicModelType,\n  CreateStoreFn,\n  CreateStoreOnlyModels,\n  Middleware,\n  UnionActions,\n} from './types';\n\nexport default function applyMiddleware(...middleware: Array<Middleware>) {\n  const nextMiddleware = [...middleware];\n  return <T extends BasicModelType<T>>(\n    createStore: CreateStoreFn<T>\n  ) => (config: {\n    models: CreateStoreOnlyModels<T>;\n    initialValue?: {\n      [key in keyof T]?: any;\n    };\n  }) => {\n    const store = createStore(config);\n    const initialState = store.getState();\n\n    const api = {\n      dispatch: (actions: UnionActions, ...rest: Array<any>) =>\n        store.dispatch(actions, ...rest),\n      getState: () => initialState,\n      store,\n    };\n\n    const chain = nextMiddleware.map(middleware => middleware<T>(api));\n    store.decorateDispatch(compose(...chain));\n\n    return store;\n  };\n}\n","// https://github.com/reduxjs/redux/blob/master/src/compose.ts\n\nexport default function compose(...funcs: Array<Function>) {\n  if (funcs.length === 0) {\n    return (arg: any) => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce((a, b) => (...args: Array<Function>) => a(b(...args)));\n}\n","import Store from './Store';\n\nimport {\n  CreateStoreOnlyModels,\n  EnhanceFunction,\n  BasicModelType,\n} from './types';\n\nexport default function createStore<\n  T extends BasicModelType<T>,\n  MODEL_KEY extends keyof T = keyof T\n>(\n  configs: {\n    models: CreateStoreOnlyModels<T>;\n    initialValue?: {\n      [key in MODEL_KEY]?: any;\n    };\n  },\n  enhancer?: EnhanceFunction\n): Store<T> {\n  if (typeof enhancer === 'function') {\n    return enhancer<T, MODEL_KEY>(createStore)(configs);\n  }\n\n  return new Store(configs);\n}\n","import print from './print';\nimport { Next, Action, ApplyMiddlewareAPI, BasicModelType } from '../../types';\n\nexport default <T extends BasicModelType<T>>({\n  getState,\n}: ApplyMiddlewareAPI<T>) => (next: Next) => (\n  actions: Array<Action> | Function\n) => {\n  if (typeof actions !== 'function') {\n    const startTime = Date.now();\n    const prevState = JSON.parse(JSON.stringify(getState()));\n\n    next(actions);\n\n    const endTime = Date.now();\n\n    print({\n      actions,\n      prevState,\n      initialActions: actions,\n      startTime,\n      endTime,\n    });\n  }\n};\n\n// 结束的时间点。。。\n// 如果同步的reducers的话，最外层运行结束就是一个结点\n// 如果说是一个effect的话，这个时候会有很多的不确定性。或者同样是以外层结束作为一个结点；\n// 然后每一次有sub结束完就搞一次；最终的结论就是一个action可能会有多个的log\n","import {\n  Next,\n  Action,\n  ThunkFn,\n  InternalDispatch,\n  ThunkDispatch,\n  BasicModelType,\n  ApplyMiddlewareAPI,\n  ExtractEffectsTypeOnlyModels,\n} from '../types';\n\n/**\n * The basic format of action type is `storeKey/${type}`.\n * Only action in effect could ignore `storeKey`\n */\nexport default <T extends BasicModelType<T>>({\n  getState,\n  dispatch,\n  store,\n}: ApplyMiddlewareAPI<T>) => (next: Next) => (\n  actions: Array<Action> | Function,\n  storeKey: keyof T\n) => {\n  if (typeof actions === 'function') {\n    const nextDispatch = (thunkActions: Array<Action> | Action) => {\n      const nextArgs = ([] as Array<Action>).concat(thunkActions) || [];\n      const actions = nextArgs\n        .map(action => {\n          if (!action) return null;\n          const { type, payload } = action;\n          const parts = [storeKey].concat(type.split('/') as any).slice(-2);\n          const nextAction: Action = {\n            type: parts.join('/'),\n          };\n          if (payload) {\n            nextAction.payload = payload;\n          }\n\n          return nextAction;\n        })\n        .filter(v => !!v) as Array<Action>;\n      if (actions.length) dispatch && (dispatch as InternalDispatch)(actions);\n    };\n    return actions(nextDispatch, getState);\n  }\n\n  const nextActions = ([] as Array<Action>).concat(actions);\n  const reducerActions: Array<Action> = [];\n  const effectActions: Array<Action> = [];\n\n  nextActions\n    .filter(action => {\n      if (Object.prototype.toString.call(action) === '[object Object]') {\n        const { type } = action;\n        return !!type;\n      }\n\n      return false;\n    })\n    .forEach(function(action: Action) {\n      try {\n        const { type } = action;\n        const parts = type.split('/');\n        const storeKey = parts[0] as keyof T;\n        const actionType = parts[1] as keyof ExtractEffectsTypeOnlyModels<\n          T\n        >[typeof storeKey];\n        const currentEffects = store.getEffects()[storeKey];\n\n        if (currentEffects && currentEffects[actionType]) {\n          return effectActions.push(action);\n        }\n\n        // If you dispatch an unregistered model's effect, it will be\n        // considered as an normal reducer action..\n        return reducerActions.push(action);\n      } catch (info) {\n        return false;\n      }\n    });\n\n  if (reducerActions.length) {\n    next(reducerActions);\n  }\n\n  effectActions.forEach(action => {\n    const { type, payload } = action;\n    const parts = type.split('/');\n    const storeKey = parts[0] as keyof T;\n    const actionType = parts[1] as keyof ExtractEffectsTypeOnlyModels<\n      T\n    >[keyof T];\n    const currentEffects = store.getEffects()[storeKey];\n    const handler = (currentEffects[actionType] as unknown) as ThunkFn<T>;\n\n    dispatch && (dispatch as ThunkDispatch<T>)(handler(payload), storeKey);\n  });\n};\n","import { useContext } from 'react';\nimport context from '../context';\nimport { ContextDefaultValue, RelinxDispatch } from '../types';\n\nexport default <T, M>(): [RelinxDispatch<T, M>] => {\n  const { dispatch } = useContext<ContextDefaultValue<T, M>>(context);\n  return [dispatch as RelinxDispatch<T, M>];\n};\n","import { useContext } from 'react';\nimport context from '../context';\n\nexport default (): string => {\n  const { namespace } = useContext(context);\n  return namespace!;\n};\n","import { useContext } from 'react';\nimport context from '../context';\nimport {\n  RelinxState,\n  RelinxDispatch,\n  UseRelinxReturnValue,\n  ContextDefaultValue,\n} from '../types';\n\nexport default <T, M, K extends keyof T = any>(\n  storeName?: K\n): UseRelinxReturnValue<T, M, K> => {\n  const { dispatch, application, componentName, $_modelKey } = useContext<\n    ContextDefaultValue<T, M>\n  >(context);\n\n  const nextStoreName = storeName || $_modelKey;\n  const proxyState = application?.proxyState;\n  const state = proxyState!.peek([nextStoreName as string]);\n  const tracker = state.getTracker();\n  tracker.setContext(componentName!);\n\n  return [\n    (state as any) as RelinxState<T, M, K>,\n    dispatch as RelinxDispatch<T, M>,\n  ];\n};\n"],"names":["noop","defaultValue","computation","dispatch","attachStoreName","useProxy","namespace","patcher","trackerNode","useRelinkMode","application","Field","createContext","infoLog","args","console","log","PathNode","constructor","prop","parent","children","patchers","autoRunners","addPatcher","path","addPathNode","Patchers","destroyPatcher","addAutoRunner","autoRunner","AutoRunners","destroyAutoRunner","getCollection","field","this","handler","len","length","reduce","node","cur","index","collection","push","addRemover","indexOf","splice","err","destroyPathNode","forEach","Object","keys","key","toString","Function","call","bind","prototype","hasOwnProperty","is","x","y","Application","base","strictMode","autoRunnerNode","pendingPatchers","pendingAutoRunners","pendingCleaner","proxyState","produce","processAutoRunner","values","value","treeShakeAutoRunner","update","treeShake","updateBase","triggerAutoRun","clean","updateDryRun","actions","concat","storeKey","changedValue","relink","addPatchers","markDirty","addAutoRunners","isDirty","markClean","compare","branch","baseValue","nextValue","cb","oldValue","newValue","o2","obj","objA","objB","keysA","keysB","i","shallowEqual","isNumber","isString","isBoolean","isObject","isArray","isMutable","pathNode","paths","fullPath","getStoreData","storeName","seenKeys","MULTIPLIER","Math","pow","patcherSeenKeys","generatePatcherKey","componentName","count","AutoRunner","autoRunFn","modelKey","id","_isDirty","removers","remover","teardown","map","action","type","payload","test","autoRun","fn","invariant","state","enter","getContext","getCurrent","getRemarkable","leave","Store","configs","models","initialValue","_state","_reducers","_effects","_pendingActions","_pendingAutoRunInitializations","injectModel","_application","subscriptions","_count","getState","getReducers","getEffects","resolveActions","changedValueGroup","actionType","split","usedReducer","warn","setValue","nextActions","changedValues","derivedActions","derivedChangedValue","storeSubscriptionsKeys","storeSubscriptionsKeysLength","toObject","acc","oldState","_this$_application3","newState","_this$_application4","subscription","diff","bindApplication","runPendingAutoRunInitialization","initialization","decorateDispatch","chainedMiddleware","generateSubscriptionKey","subscribe","model","reducers","effects","nextPendingActions","filter","reducer","effect","nextState","autoRunKey","GlobalHelper","collections","addAction","actionKey","findIndex","targetNamespace","floor","random","globalHelper","padding","paddingCount","slice","formatTime","d","date","Date","hh","getHours","mm","getMinutes","ss","getSeconds","ms","getMilliseconds","colorLine","apply","colorGroupEnd","groupEnd","colorGroupCollapsed","groupCollapsed","colorLog","group","text","t","styles","s","subText","subStyle","paint","tree","actionKeys","effectKeys","props","style","parts","renderSubAction","Patcher","displayName","dirty","child","removeChild","appendTo","belongs","markDirtyAll","Helper","addListener","store","useScope","namespaceRef","useRef","undefined","isNaN","generateNamespaceKey","current","contextValue","React","context","Provider","middleware","nextMiddleware","createStore","config","initialState","api","rest","chain","funcs","arg","a","b","compose","enhancer","next","startTime","now","prevState","JSON","parse","stringify","initialActions","endTime","title","actionColor","startsWith","renderTitle","isNextState","renderState","paintActions","print","WrappedComponent","NextComponent","shadowState","_","setState","useState","patcherUpdated","isMounted","$_modelKey","restProps","useEffect","parentPatcher","useContext","incrementCount","useCallback","Fragment","name","memo","thunkActions","nextAction","join","v","reducerActions","effectActions","currentEffects","info","nextStoreName","peek","getTracker","setContext"],"mappings":"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"}